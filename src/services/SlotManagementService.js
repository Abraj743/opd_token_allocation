const BaseService = require('./BaseService');
const { globalAuditLogger, AUDIT_EVENT_TYPES, AUDIT_SEVERITY } = require('../utils/auditLogger');


class SlotManagementService extends BaseService {
  constructor({ slotRepository, tokenRepository, configurationService, logger }) {
    super({ logger });
    this.slotRepository = slotRepository;
    this.tokenRepository = tokenRepository;
    this.configurationService = configurationService;
  }

 
  async createSlotsFromSchedule(doctorId, startDate, endDate, options = {}) {
    return this.executeOperation('createSlotsFromSchedule', async () => {
      this.validateRequired({ doctorId, startDate, endDate }, ['doctorId', 'startDate', 'endDate']);
      
      // Get doctor's weekly schedule
      const doctor = await this.getDoctorSchedule(doctorId);
      if (!doctor || !doctor.schedule || doctor.schedule.length === 0) {
        return this.createErrorResponse(
          'NO_DOCTOR_SCHEDULE',
          'Doctor schedule not found or empty',
          { doctorId },
          ['Configure doctor schedule first', 'Contact administration']
        );
      }

      const start = new Date(startDate);
      const end = new Date(endDate);
      
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return this.createErrorResponse(
          'INVALID_DATE_RANGE',
          'Invalid date format',
          { startDate, endDate },
          ['Use YYYY-MM-DD format']
        );
      }

      if (start >= end) {
        return this.createErrorResponse(
          'INVALID_DATE_RANGE',
          'Start date must be before end date',
          { startDate, endDate },
          ['Ensure start date is before end date']
        );
      }

      const createdSlots = [];
      const errors = [];
      const currentDate = new Date(start);

      // Iterate through each date in the range
      while (currentDate <= end) {
        const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
        
        // Find schedule for this day of week
        const daySchedule = doctor.schedule.find(schedule => schedule.dayOfWeek === dayOfWeek);
        
        if (daySchedule && daySchedule.timeSlots && daySchedule.timeSlots.length > 0) {
          // Create slots for each time slot in the day's schedule
          for (const timeSlot of daySchedule.timeSlots) {
            try {
              const slotResult = await this.createTimeSlot(
                doctorId,
                currentDate.toISOString().split('T')[0], // YYYY-MM-DD format
                timeSlot.startTime,
                timeSlot.endTime,
                timeSlot.capacity || options.defaultCapacity || 10,
                {
                  specialty: doctor.specialty || 'general',
                  averageConsultationTime: timeSlot.consultationTime || 15,
                  bufferTime: timeSlot.bufferTime || 5,
                  emergencyReserved: Math.ceil((timeSlot.capacity || 10) * 0.1),
                  autoGenerated: true,
                  generatedFrom: 'weekly_schedule'
                }
              );

              if (slotResult.success) {
                createdSlots.push(slotResult.data);
              } else {
                errors.push({
                  date: currentDate.toISOString().split('T')[0],
                  timeSlot: `${timeSlot.startTime}-${timeSlot.endTime}`,
                  error: slotResult.message
                });
              }
            } catch (error) {
              errors.push({
                date: currentDate.toISOString().split('T')[0],
                timeSlot: `${timeSlot.startTime}-${timeSlot.endTime}`,
                error: error.message
              });
            }
          }
        }

        // Move to next day
        currentDate.setDate(currentDate.getDate() + 1);
      }

      const result = {
        createdSlots,
        totalCreated: createdSlots.length,
        errors,
        errorCount: errors.length,
        dateRange: { startDate, endDate },
        doctorId
      };

      if (errors.length > 0) {
        return this.createSuccessResponse(
          result,
          `Created ${createdSlots.length} slots with ${errors.length} errors`
        );
      }

      return this.createSuccessResponse(
        result,
        `Successfully created ${createdSlots.length} slots from doctor schedule`
      );
    }, { doctorId, startDate, endDate });
  }

  
  async getDoctorSchedule(doctorId) {
    
    try {
     
      if (this.doctorRepository) {
        return await this.doctorRepository.findById(doctorId);
      }
      
     
      const existingSlots = await this.slotRepository.find({ doctorId });
      if (existingSlots.length > 0) {
     
        const scheduleMap = new Map();
        
        existingSlots.forEach(slot => {
          const dayOfWeek = new Date(slot.date).getDay();
          if (!scheduleMap.has(dayOfWeek)) {
            scheduleMap.set(dayOfWeek, []);
          }
          scheduleMap.get(dayOfWeek).push({
            startTime: slot.startTime,
            endTime: slot.endTime,
            capacity: slot.maxCapacity
          });
        });

        const schedule = Array.from(scheduleMap.entries()).map(([dayOfWeek, timeSlots]) => ({
          dayOfWeek,
          timeSlots
        }));

        return {
          doctorId,
          schedule,
          specialty: existingSlots[0].specialty || 'general'
        };
      }

      return null;
    } catch (error) {
      this.logger.error('Error getting doctor schedule:', error);
      return null;
    }
  }

  
  async createTimeSlot(doctorId, date, startTime, endTime, capacity, options = {}) {
    return this.executeOperation('createTimeSlot', async () => {
      this.validateRequired({ doctorId, date, startTime, endTime, capacity }, 
        ['doctorId', 'date', 'startTime', 'endTime', 'capacity']);
      
      // Validate capacity
      if (capacity <= 0) {
        return this.createErrorResponse(
          'INVALID_CAPACITY',
          'Slot capacity must be greater than 0',
          { capacity },
          ['Set capacity to a positive number']
        );
      }

      // Validate time format
      if (!this.isValidTimeFormat(startTime) || !this.isValidTimeFormat(endTime)) {
        return this.createErrorResponse(
          'INVALID_TIME_FORMAT',
          'Time must be in HH:mm format',
          { startTime, endTime },
          ['Use HH:mm format (e.g., 09:00, 14:30)']
        );
      }

      // Validate date
      const slotDate = new Date(date);
      if (isNaN(slotDate.getTime())) {
        return this.createErrorResponse(
          'INVALID_DATE',
          'Invalid date format',
          { date },
          ['Use YYYY-MM-DD format']
        );
      }

      // Check for overlapping slots
      const overlappingSlots = await this.slotRepository.findOverlappingSlots(
        doctorId, date, startTime, endTime
      );

      if (overlappingSlots.length > 0) {
        return this.createErrorResponse(
          'SLOT_OVERLAP',
          'Time slot overlaps with existing slots',
          { overlappingSlots: overlappingSlots.map(s => ({ 
            slotId: s.slotId, 
            startTime: s.startTime, 
            endTime: s.endTime 
          })) },
          ['Choose a different time range', 'Modify existing overlapping slots']
        );
      }

      const slotData = {
        slotId: `slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        doctorId,
        date: slotDate,
        startTime,
        endTime,
        maxCapacity: capacity,
        currentAllocation: 0,
        status: 'active',
        specialty: options.specialty || 'general',
        metadata: {
          averageConsultationTime: options.averageConsultationTime || 15,
          bufferTime: options.bufferTime || 5,
          emergencyReserved: options.emergencyReserved || Math.ceil(capacity * 0.1)
        },
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const slot = await this.slotRepository.create(slotData);

      globalAuditLogger.logSlotOperation('create', slot, {
        severity: AUDIT_SEVERITY.MEDIUM
      });

      return this.createSuccessResponse(
        { slot },
        'Time slot created successfully'
      );
    }, { doctorId, date, startTime, endTime, capacity });
  }

  
  async updateSlotCapacity(slotId, newCapacity) {
    return this.executeOperation('updateSlotCapacity', async () => {
      this.validateRequired({ slotId, newCapacity }, ['slotId', 'newCapacity']);
      
      if (newCapacity <= 0) {
        return this.createErrorResponse(
          'INVALID_CAPACITY',
          'Slot capacity must be greater than 0',
          { newCapacity },
          ['Set capacity to a positive number']
        );
      }

      const slot = await this.slotRepository.findBySlotId(slotId);
      if (!slot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      // Check if new capacity is less than current allocation
      if (newCapacity < slot.currentAllocation) {
        return this.createErrorResponse(
          'CAPACITY_BELOW_ALLOCATION',
          'New capacity cannot be less than current allocation',
          { 
            newCapacity, 
            currentAllocation: slot.currentAllocation,
            allocatedTokens: slot.currentAllocation
          },
          [
            `Set capacity to at least ${slot.currentAllocation}`,
            'Cancel some tokens before reducing capacity'
          ]
        );
      }

      const updatedSlot = await this.slotRepository.updateCapacity(slotId, newCapacity);
      
      // Update emergency reserved slots
      const emergencyReserved = Math.ceil(newCapacity * 0.1);
      await this.slotRepository.updateMetadata(slotId, { emergencyReserved });

      return this.createSuccessResponse(
        updatedSlot,
        'Slot capacity updated successfully'
      );
    }, { slotId, newCapacity });
  }

  
  async getAvailableSlots(criteria = {}) {
    return this.executeOperation('getAvailableSlots', async () => {
      const searchCriteria = {
        status: 'active'
      };

     
      Object.keys(criteria).forEach(key => {
        if (key !== 'date' && key !== 'startDate' && key !== 'endDate') {
          searchCriteria[key] = criteria[key];
        }
      });

     
      if (criteria.date) {
        
        const targetDate = new Date(criteria.date);
        
        const startOfDay = new Date(Date.UTC(targetDate.getUTCFullYear(), targetDate.getUTCMonth(), targetDate.getUTCDate()));
        const endOfDay = new Date(Date.UTC(targetDate.getUTCFullYear(), targetDate.getUTCMonth(), targetDate.getUTCDate(), 23, 59, 59, 999));
        
        searchCriteria.date = {
          $gte: startOfDay,
          $lte: endOfDay
        };
      } else if (criteria.startDate || criteria.endDate) {
       
        searchCriteria.date = {};
        if (criteria.startDate) {
          searchCriteria.date.$gte = new Date(criteria.startDate);
        }
        if (criteria.endDate) {
          searchCriteria.date.$lte = new Date(criteria.endDate);
        }
      }

      const slots = await this.slotRepository.findAvailable(searchCriteria);
      
      
      const slotsWithAvailability = slots.map((slot) => {
        const currentAllocation = slot.currentAllocation || 0;
        const availableCapacity = slot.maxCapacity - currentAllocation;
        const utilizationRate = (currentAllocation / slot.maxCapacity) * 100;
        
        return {
          ...slot.toObject(),
          currentAllocation,
          availableCapacity,
          utilizationRate: Math.round(utilizationRate * 100) / 100,
          isAvailable: availableCapacity > 0
        };
      });

     
      const filteredSlots = criteria.onlyAvailable 
        ? slotsWithAvailability.filter(slot => slot.isAvailable)
        : slotsWithAvailability;

      
      filteredSlots.sort((a, b) => {
        const dateCompare = new Date(a.date) - new Date(b.date);
        if (dateCompare !== 0) return dateCompare;
        return a.startTime.localeCompare(b.startTime);
      });

      return this.createSuccessResponse(
        {
          slots: filteredSlots,
          totalSlots: filteredSlots.length,
          availableSlots: filteredSlots.filter(s => s.isAvailable).length
        },
        `Found ${filteredSlots.length} slots`
      );
    }, criteria);
  }

  
  async getCurrentAllocation(slotId) {
    if (!this.tokenRepository) {
      const slot = await this.slotRepository.findBySlotId(slotId);
      return slot ? slot.currentAllocation : 0;
    }
    
    const tokens = await this.tokenRepository.findBySlot(slotId);
    const activeTokens = tokens.filter(token => 
      ['allocated', 'confirmed'].includes(token.status)
    );
    return activeTokens.length;
  }

  
  async checkSlotAvailability(slotId, requiredCapacity = 1) {
    return this.executeOperation('checkSlotAvailability', async () => {
      this.validateRequired({ slotId }, ['slotId']);
      
      const slot = await this.slotRepository.findBySlotId(slotId);
      if (!slot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      if (slot.status !== 'active') {
        return this.createErrorResponse(
          'SLOT_INACTIVE',
          'Slot is not active',
          { status: slot.status },
          ['Activate the slot', 'Choose a different slot']
        );
      }

      const currentAllocation = slot.currentAllocation;
      const availableCapacity = slot.maxCapacity - currentAllocation;
      const hasCapacity = availableCapacity >= requiredCapacity;
      const utilizationPercentage = (currentAllocation / slot.maxCapacity) * 100;

      const result = {
        slotId,
        maxCapacity: slot.maxCapacity,
        currentAllocation,
        availableCapacity,
        requiredCapacity,
        hasCapacity,
        isAvailable: hasCapacity,
        utilizationPercentage: Math.round(utilizationPercentage * 100) / 100
      };

      
      return this.createSuccessResponse(
        result,
        hasCapacity ? 'Slot has available capacity' : 'Slot is at full capacity'
      );
    }, { slotId, requiredCapacity });
  }

  
  async updateSlotStatus(slotId, status) {
    return this.executeOperation('updateSlotStatus', async () => {
      this.validateRequired({ slotId, status }, ['slotId', 'status']);
      
      const validStatuses = ['active', 'suspended', 'completed', 'cancelled'];
      if (!validStatuses.includes(status)) {
        return this.createErrorResponse(
          'INVALID_STATUS',
          `Invalid status. Must be one of: ${validStatuses.join(', ')}`
        );
      }

      // Get current slot to track previous status
      const currentSlot = await this.slotRepository.findBySlotId(slotId);
      if (!currentSlot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      const previousStatus = currentSlot.status;
      const updatedSlot = await this.slotRepository.updateStatus(slotId, status);
      
      if (!updatedSlot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      return this.createSuccessResponse(
        {
          slot: updatedSlot,
          previousStatus
        },
        `Slot status updated to ${status}`
      );
    }, { slotId, status });
  }

  
  async getSlotStatistics(criteria = {}) {
    return this.executeOperation('getSlotStatistics', async () => {
      const stats = await this.slotRepository.getStatistics(criteria);
      
      const result = {
        totalSlots: stats.totalSlots,
        activeSlots: stats.activeSlots,
        suspendedSlots: stats.suspendedSlots,
        completedSlots: stats.completedSlots,
        totalCapacity: stats.totalCapacity,
        totalAllocated: stats.totalAllocated,
        averageUtilization: stats.totalCapacity > 0 
          ? Math.round((stats.totalAllocated / stats.totalCapacity) * 100 * 100) / 100
          : 0,
        availableCapacity: stats.totalCapacity - stats.totalAllocated
      };

      return this.createSuccessResponse(
        result,
        'Slot statistics retrieved successfully'
      );
    }, criteria);
  }

  
  async findAlternativeSlots(originalSlot, timeWindowHours = 2) {
    return this.executeOperation('findAlternativeSlots', async () => {
      this.validateRequired({ originalSlot }, ['originalSlot']);
      
      const originalDate = new Date(originalSlot.date);
      const startWindow = new Date(originalDate.getTime() - (timeWindowHours * 60 * 60 * 1000));
      const endWindow = new Date(originalDate.getTime() + (timeWindowHours * 60 * 60 * 1000));

      const criteria = {
        doctorId: originalSlot.doctorId,
        startDate: startWindow,
        endDate: endWindow,
        onlyAvailable: true
      };

      const availableSlotsResult = await this.getAvailableSlots(criteria);
      
      if (!availableSlotsResult.success) {
        return availableSlotsResult;
      }

      const alternatives = availableSlotsResult.data.slots
        .filter(slot => slot.slotId !== originalSlot.slotId)
        .map(slot => ({
          ...slot,
          timeDifference: Math.abs(new Date(slot.date).getTime() - originalDate.getTime()) / (1000 * 60 * 60),
          sameDay: new Date(slot.date).toDateString() === originalDate.toDateString()
        }))
        .sort((a, b) => a.timeDifference - b.timeDifference);

      return this.createSuccessResponse(
        {
          originalSlot,
          alternatives,
          timeWindow: timeWindowHours,
          totalAlternatives: alternatives.length
        },
        `Found ${alternatives.length} alternative slots`
      );
    }, { originalSlotId: originalSlot?.slotId, timeWindowHours });
  }

  isValidTimeFormat(time) {
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    return timeRegex.test(time);
  }

  
  async incrementAllocation(slotId) {
    return this.executeOperation('incrementAllocation', async () => {
      const updatedSlot = await this.slotRepository.incrementAllocation(slotId);
      
      if (!updatedSlot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      return this.createSuccessResponse(
        updatedSlot,
        'Slot allocation incremented'
      );
    }, { slotId });
  }


  async decrementAllocation(slotId) {
    return this.executeOperation('decrementAllocation', async () => {
      const updatedSlot = await this.slotRepository.decrementAllocation(slotId);
      
      if (!updatedSlot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      return this.createSuccessResponse(
        updatedSlot,
        'Slot allocation decremented'
      );
    }, { slotId });
  }

  
  async createSlot(slotData) {
    return this.executeOperation('createSlot', async () => {
      this.validateRequired(slotData, ['slotId', 'doctorId', 'date', 'startTime', 'endTime', 'maxCapacity']);
      
      // Check if slot already exists
      const existingSlot = await this.slotRepository.findBySlotId(slotData.slotId);
      if (existingSlot) {
        return this.createErrorResponse(
          'SLOT_ALREADY_EXISTS',
          `Slot with ID ${slotData.slotId} already exists`,
          { slotId: slotData.slotId },
          ['Use a different slot ID', 'Update the existing slot instead']
        );
      }

      // Validate time format
      if (!this.isValidTimeFormat(slotData.startTime) || !this.isValidTimeFormat(slotData.endTime)) {
        return this.createErrorResponse(
          'INVALID_TIME_FORMAT',
          'Time must be in HH:mm format',
          { startTime: slotData.startTime, endTime: slotData.endTime },
          ['Use HH:mm format (e.g., 09:00, 14:30)']
        );
      }

      // Validate capacity
      if (slotData.maxCapacity <= 0) {
        return this.createErrorResponse(
          'INVALID_CAPACITY',
          'Slot capacity must be greater than 0',
          { maxCapacity: slotData.maxCapacity },
          ['Set capacity to a positive number']
        );
      }

      // Validate date
      const slotDate = new Date(slotData.date);
      if (isNaN(slotDate.getTime())) {
        return this.createErrorResponse(
          'INVALID_DATE',
          'Invalid date format',
          { date: slotData.date },
          ['Use a valid date format']
        );
      }

      // Check for overlapping slots
      const overlappingSlots = await this.slotRepository.findOverlappingSlots(
        slotData.doctorId, 
        slotDate.toISOString().split('T')[0], 
        slotData.startTime, 
        slotData.endTime
      );

      if (overlappingSlots.length > 0) {
        return this.createErrorResponse(
          'SLOT_OVERLAP',
          'Time slot overlaps with existing slots',
          { overlappingSlots: overlappingSlots.map(s => ({ 
            slotId: s.slotId, 
            startTime: s.startTime, 
            endTime: s.endTime 
          })) },
          ['Choose a different time range', 'Modify existing overlapping slots']
        );
      }

      // Create the slot
      const slot = await this.slotRepository.create({
        ...slotData,
        date: slotDate,
        currentAllocation: slotData.currentAllocation || 0,
        status: slotData.status || 'active',
        specialty: slotData.specialty || 'general',
        lastTokenNumber: slotData.lastTokenNumber || 0,
        metadata: slotData.metadata || {
          averageConsultationTime: 15,
          bufferTime: 5,
          emergencyReserved: Math.ceil(slotData.maxCapacity * 0.1)
        },
        createdAt: new Date(),
        updatedAt: new Date()
      });

      
      globalAuditLogger.logSlotOperation('create', slot, {
        severity: AUDIT_SEVERITY.MEDIUM
      });

      return this.createSuccessResponse(
        { slot },
        'Time slot created successfully'
      );
    }, slotData);
  }

  async allocateSlotCapacity(slotId, amount = 1) {
    return this.executeOperation('allocateSlotCapacity', async () => {
      this.validateRequired({ slotId }, ['slotId']);
      
      const slot = await this.slotRepository.findBySlotId(slotId);
      if (!slot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      // Check if allocation would exceed capacity
      if (slot.currentAllocation + amount > slot.maxCapacity) {
        return this.createErrorResponse(
          'SLOT_CAPACITY_EXCEEDED',
          'Allocation would exceed slot capacity',
          { 
            currentAllocation: slot.currentAllocation,
            maxCapacity: slot.maxCapacity,
            requestedAmount: amount,
            availableCapacity: slot.maxCapacity - slot.currentAllocation
          },
          [`Reduce allocation to ${slot.maxCapacity - slot.currentAllocation} or less`, 'Increase slot capacity']
        );
      }

      const previousAllocation = slot.currentAllocation;
      const updatedSlot = await this.slotRepository.incrementAllocation(slotId, amount);

      return this.createSuccessResponse(
        { 
          slot: updatedSlot,
          previousAllocation,
          allocatedAmount: amount
        },
        `Slot capacity allocated: ${amount} slot(s)`
      );
    }, { slotId, amount });
  }

  
  async deallocateSlotCapacity(slotId, amount = 1) {
    return this.executeOperation('deallocateSlotCapacity', async () => {
      this.validateRequired({ slotId }, ['slotId']);
      
      const slot = await this.slotRepository.findBySlotId(slotId);
      if (!slot) {
        return this.createErrorResponse(
          'SLOT_NOT_FOUND',
          `Slot with ID ${slotId} not found`
        );
      }

      // Check if deallocation would go below zero
      if (slot.currentAllocation - amount < 0) {
        return this.createErrorResponse(
          'SLOT_ALLOCATION_UNDERFLOW',
          'Deallocation would result in negative allocation',
          { 
            currentAllocation: slot.currentAllocation,
            requestedAmount: amount,
            maxDeallocation: slot.currentAllocation
          },
          [`Reduce deallocation to ${slot.currentAllocation} or less`]
        );
      }

      const previousAllocation = slot.currentAllocation;
      const updatedSlot = await this.slotRepository.decrementAllocation(slotId, amount);

      return this.createSuccessResponse(
        { 
          slot: updatedSlot,
          previousAllocation,
          deallocatedAmount: amount
        },
        `Slot capacity deallocated: ${amount} slot(s)`
      );
    }, { slotId, amount });
  }

  
  async getAvailableSlotsForDoctor(doctorId, date) {
    return this.executeOperation('getAvailableSlotsForDoctor', async () => {
      this.validateRequired({ doctorId, date }, ['doctorId', 'date']);
      
      const slots = await this.slotRepository.findAvailableSlots(doctorId, date);
      
      // Calculate availability for each slot
      const slotsWithAvailability = slots.map(slot => ({
        ...slot.toObject(),
        isAvailable: slot.currentAllocation < slot.maxCapacity,
        availableCapacity: slot.maxCapacity - slot.currentAllocation,
        utilizationPercentage: Math.round((slot.currentAllocation / slot.maxCapacity) * 100)
      }));

      // Filter only available slots
      const availableSlots = slotsWithAvailability.filter(slot => slot.isAvailable);

      return this.createSuccessResponse(
        { 
          slots: availableSlots,
          totalSlots: availableSlots.length
        },
        `Found ${availableSlots.length} available slots`
      );
    }, { doctorId, date });
  }

  
  async generateFutureSlots(doctorSchedule, startDate, days, options = {}) {
    return this.executeOperation('generateFutureSlots', async () => {
      this.validateRequired({ doctorSchedule, startDate, days }, ['doctorSchedule', 'startDate', 'days']);
      
      const createdSlots = [];
      const errors = [];
      const currentDate = new Date(startDate);
      const endDate = new Date(startDate.getTime() + (days * 24 * 60 * 60 * 1000));

      // Iterate through each date in the range
      while (currentDate < endDate) {
        const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
        
        // Skip weekends if requested
        if (options.excludeWeekends && (dayOfWeek === 0 || dayOfWeek === 6)) {
          currentDate.setDate(currentDate.getDate() + 1);
          continue;
        }
        
        // Find schedule for this day of week
        const daySchedule = doctorSchedule.schedule.find(schedule => schedule.dayOfWeek === dayOfWeek);
        
        if (daySchedule && daySchedule.slots && daySchedule.slots.length > 0) {
          // Create slots for each time slot in the day's schedule
          for (const timeSlot of daySchedule.slots) {
            try {
              const slotData = {
                slotId: `slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                doctorId: doctorSchedule.doctorId,
                date: new Date(currentDate),
                startTime: timeSlot.startTime,
                endTime: timeSlot.endTime,
                maxCapacity: timeSlot.capacity || 5,
                currentAllocation: 0,
                status: 'active',
                specialty: doctorSchedule.specialty || 'general',
                lastTokenNumber: 0
              };

              const slotResult = await this.createSlot(slotData);

              if (slotResult.success) {
                createdSlots.push(slotResult.data.slot);
              } else {
                errors.push({
                  date: currentDate.toISOString().split('T')[0],
                  timeSlot: `${timeSlot.startTime}-${timeSlot.endTime}`,
                  error: slotResult.message
                });
              }
            } catch (error) {
              errors.push({
                date: currentDate.toISOString().split('T')[0],
                timeSlot: `${timeSlot.startTime}-${timeSlot.endTime}`,
                error: error.message
              });
            }
          }
        }

        // Move to next day
        currentDate.setDate(currentDate.getDate() + 1);
      }

      const result = {
        slots: createdSlots,
        slotsGenerated: createdSlots.length,
        errors,
        errorCount: errors.length,
        dateRange: { startDate, endDate: new Date(endDate) },
        doctorId: doctorSchedule.doctorId
      };

      if (errors.length > 0) {
        return this.createSuccessResponse(
          result,
          `Generated ${createdSlots.length} slots with ${errors.length} errors`
        );
      }

      return this.createSuccessResponse(
        result,
        `Successfully generated ${createdSlots.length} future slots`
      );
    }, { doctorId: doctorSchedule?.doctorId, startDate, days });
  }

  
  async bulkAllocateCapacity(doctorId, date, amount) {
    return this.executeOperation('bulkAllocateCapacity', async () => {
      this.validateRequired({ doctorId, date, amount }, ['doctorId', 'date', 'amount']);
      
      const slots = await this.slotRepository.findByDoctorAndDate(doctorId, date);
      const updatedSlots = [];
      const errors = [];

      for (const slot of slots) {
        try {
          const allocationResult = await this.allocateSlotCapacity(slot.slotId, amount);
          if (allocationResult.success) {
            updatedSlots.push(allocationResult.data.slot);
          } else {
            errors.push({
              slotId: slot.slotId,
              error: allocationResult.message
            });
          }
        } catch (error) {
          errors.push({
            slotId: slot.slotId,
            error: error.message
          });
        }
      }

      return this.createSuccessResponse(
        {
          slotsUpdated: updatedSlots.length,
          updatedSlots,
          errors,
          errorCount: errors.length
        },
        `Bulk allocation completed: ${updatedSlots.length} slots updated`
      );
    }, { doctorId, date, amount });
  }

 
  async getTotalCapacity(doctorId, date) {
    return this.executeOperation('getTotalCapacity', async () => {
      this.validateRequired({ doctorId, date }, ['doctorId', 'date']);
      
      const slots = await this.slotRepository.findByDoctorAndDate(doctorId, date);
      
      const totalCapacity = slots.reduce((sum, slot) => sum + slot.maxCapacity, 0);
      const totalAllocated = slots.reduce((sum, slot) => sum + slot.currentAllocation, 0);
      const totalAvailable = totalCapacity - totalAllocated;
      const utilizationPercentage = totalCapacity > 0 ? (totalAllocated / totalCapacity) * 100 : 0;

      return this.createSuccessResponse(
        {
          totalCapacity,
          totalAllocated,
          totalAvailable,
          utilizationPercentage: Math.round(utilizationPercentage * 100) / 100,
          totalSlots: slots.length
        },
        `Total capacity calculated for ${slots.length} slots`
      );
    }, { doctorId, date });
  }

 
  async getSlotsByDoctor(doctorId, options = {}) {
    return this.executeOperation('getSlotsByDoctor', async () => {
      this.validateRequired({ doctorId }, ['doctorId']);

      const {
        date,
        dateRange,
        status = 'active',
        includeFullyBooked = true,
        page = 1,
        limit = 10,
        sort = 'asc',
        sortBy = 'date'
      } = options;

      // Build search criteria
      const searchCriteria = {
        doctorId,
        status
      };

      // Add date filtering
      if (date) {
        const searchDate = new Date(date);
        const startOfDay = new Date(searchDate);
        startOfDay.setHours(0, 0, 0, 0);
        const endOfDay = new Date(searchDate);
        endOfDay.setHours(23, 59, 59, 999);
        
        searchCriteria.date = {
          $gte: startOfDay,
          $lte: endOfDay
        };
      } else if (dateRange) {
        searchCriteria.date = {
          $gte: new Date(dateRange.startDate),
          $lte: new Date(dateRange.endDate)
        };
      }

      
      const slots = await this.slotRepository.find(
        searchCriteria,
        {
          sort: { [sortBy]: sort === 'asc' ? 1 : -1 },
          limit: parseInt(limit),
          skip: (parseInt(page) - 1) * parseInt(limit)
        }
      );

      // Filter out fully booked slots if requested
      let filteredSlots = slots;
      if (!includeFullyBooked) {
        filteredSlots = slots.filter(slot => slot.currentAllocation < slot.maxCapacity);
      }

      // Add availability information to each slot
      const slotsWithAvailability = await Promise.all(
        filteredSlots.map(async (slot) => {
          const availableCapacity = slot.maxCapacity - slot.currentAllocation;
          const utilizationRate = slot.maxCapacity > 0 
            ? Math.round((slot.currentAllocation / slot.maxCapacity) * 100) 
            : 0;

          return {
            ...slot.toObject(),
            availableCapacity,
            utilizationRate,
            isFullyBooked: availableCapacity === 0,
            isAvailable: availableCapacity > 0
          };
        })
      );

      // Get total count for pagination
      const totalCount = await this.slotRepository.count(searchCriteria);

      return this.createSuccessResponse(
        {
          slots: slotsWithAvailability,
          pagination: {
            currentPage: parseInt(page),
            totalPages: Math.ceil(totalCount / parseInt(limit)),
            totalSlots: totalCount,
            slotsPerPage: parseInt(limit),
            hasNextPage: (parseInt(page) * parseInt(limit)) < totalCount,
            hasPreviousPage: parseInt(page) > 1
          },
          summary: {
            totalSlots: slotsWithAvailability.length,
            availableSlots: slotsWithAvailability.filter(s => s.isAvailable).length,
            fullyBookedSlots: slotsWithAvailability.filter(s => s.isFullyBooked).length,
            totalCapacity: slotsWithAvailability.reduce((sum, s) => sum + s.maxCapacity, 0),
            totalAllocated: slotsWithAvailability.reduce((sum, s) => sum + s.currentAllocation, 0)
          }
        },
        `Found ${slotsWithAvailability.length} slots for doctor ${doctorId}`
      );
    }, { doctorId, options });
  }
}

module.exports = SlotManagementService;